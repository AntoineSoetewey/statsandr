---
title: "The complete guide to clustering analysis: k-means and hierarchical clustering by hand and in R"
author: Antoine Soetewey
date: "2020-02-13"
slug: clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r
categories: []
tags:
  - R
  - Statistics
meta_img: blog/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r_files/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r-statsandr.com.jpeg
description: Learn how to perform clustering analysis, namely k-means and hierarchical clustering, by hand and in R. See also how the different clustering algorithms work
output:
  blogdown::html_page:
    toc: true
    toc_depth: 6
# draft: true
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  fig.align = "center",
  out.width = "100%"
)
```

![](/blog/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r_files/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r-statsandr.com.jpeg){width=100%}

# What is clustering analysis?

Clustering analysis is a form of exploratory data analysis in which observations are divided into different groups that share common characteristics.

The purpose of cluster analysis (also known as classification) is to construct groups (or classes or *clusters*) while ensuring the following property: **within a group** the observations must be as **similar** as possible, while observations belonging to **different groups** must be as **different** as possible.

There are two main types of classification:

1. *k*-means clustering
2. Hierarchical clustering

The first is generally used when the **number of classes is fixed** in advance, while the second is generally used for an **unknown number of classes** and helps to determine this optimal number. Both methods are illustrated below through applications by hand and in R. Note that for hierarchical clustering, only the *ascending* classification is presented in this article.

Clustering algorithms use the **distance** in order to separate observations into different groups. Therefore, before diving into the presentation of the two classification methods, a reminder exercise on how to compute distances between points is presented.

## Application 1: Computing distances

Let a data set containing the points $\boldsymbol{a} = (0, 0)'$, $\boldsymbol{b} = (1, 0)'$ and $\boldsymbol{c} = (5, 5)'$. Compute the matrix of Euclidean distances between the points by hand and in R.

### Solution

The points are as follows:

```{r}
# We create the points in R
a <- c(0, 0)
b <- c(1, 0)
c <- c(5, 5)

X <- rbind(a, b, c) # a, b and c are combined per row
colnames(X) <- c("x", "y") # rename columns

X # display the points
```

By the Pythagorean theorem, we will remember that the distance between 2 points $(x_a, y_a)$ and $(x_b, y_b)$ in $\mathbb{R}^2$ is given by $\sqrt{(x_a - x_b)^2 + (y_a - y_b)^2}$. So for instance, for the distance between the points $\boldsymbol{b} = (1, 0)'$ and $\boldsymbol{c} = (5, 5)'$ presented in the statement above, we have:

\begin{equation}
  \begin{split}
        \sqrt{(x_b - x_c)^2 + (y_b - y_c)^2} &= \sqrt{(1-5)^2 + (0-5)^2}\\
        &= 6.403124
  \end{split}
\end{equation}

We can proceed similarly for all pairs of points to find the distance matrix by hand. In R, the `dist()` function allows you to find the distance of points in a matrix or dataframe in a very simple way:
 
```{r}
# The distance is found using the dist() function:
distance <- dist(X, method = "euclidean")
distance # display the distance matrix
```

Note that the argument `method = "euclidean"` is not mandatory because the Euclidean method is the default one.

The distance matrix resulting from the `dist()` function gives the distance between the different points. The Euclidean distance between the points $\boldsymbol{b}$ and $\boldsymbol{c}$ is `r round(distance[3], 6)`, which corresponds to what we found above via the Pythagorean formula.

**Note**: If two variables do not have the same units, one may have more weight in the calculation of the Euclidean distance than the other. In that case, it is preferable to scale the data. Scaling data allows to obtain variables independent of their unit, and this can be done with the [`scale()`](/blog/data-manipulation-in-r/#scale) function.

Now that the distance has been presented, let's see how to perform clustering analysis with the k-means algorithm. 

# *k*-means clustering

The first form of classification is the method called _*k*-means clustering_ or the mobile center algorithm. As a reminder, this method aims at partitioning $n$ observations into $k$ clusters in which each observation belongs to the cluster with the closest average, serving as a prototype of the cluster.

It is presented below via an application in R and by hand.

## Application 2: *k*-means clustering

### Data

For this exercise, the `Eurojobs.csv` database available [here](/blog/data/Eurojobs.csv) is used.

This database contains the percentage of the population employed in different industries in 26 European countries in 1979. It contains 10 variables:

* `Country` - the name of the country (identifier)
* `Agr` - % of workforce employed in agriculture
* `Min` - % in mining
* `Man` - % in manufacturing
* `PS` - % in power supplies industries
* `Con` - % in construction
* `SI` - % in service industries
* `Fin` - % in finance
* `SPS` - % in social and personal services
* `TC` - % in transportation and communications

We first import the dataset. See [how to import data into R](/blog/how-to-import-an-excel-file-in-rstudio/) if you need a reminder.

```{r, warning = FALSE, message = FALSE}
# Import data
Eurojobs <- read.csv(
  file = "data/Eurojobs.csv",
  sep = ",", dec = ".", header = TRUE
)
head(Eurojobs) # head() is used to display only the first 6 observations
```

Note that there is a numbering before the first variable `Country`. For more clarity, we will replace this numbering by the country. To do this, we add the argument `row.names = 1` in the import function `read.csv()` to specify that the first column corresponds to the row names:

```{r}
Eurojobs <- read.csv(
  file = "data/Eurojobs.csv",
  sep = ",", dec = ".", header = TRUE, row.names = 1
)
Eurojobs # displays dataset
dim(Eurojobs) # displays the number of rows and columns
```

We now have a "clean" dataset of 26 observations and 9 [quantitative continuous variables](/blog/variable-types-and-examples/#continuous) on which we can base the classification. Note that in this case it is not necessary to standardize the data because they are all expressed in the same unit (in percentage). If this was not the case, we would have had to standardize the data via the `scale()` function (do not forget it otherwise your results may be completely different!).

The so-called *k*-means clustering is done via the `kmeans()` function, with the argument `centers` that corresponds to the number of desired clusters. In the following we apply the classification with 2 classes and then 3 classes as examples.

### `kmeans()` with 2 groups

```{r, echo = FALSE}
set.seed(42)
```

```{r}
model <- kmeans(Eurojobs, centers = 2)

# displays the class determined by
# the model for all observations:
print(model$cluster)
```

Note that the argument `centers = 2` is used to set the number of clusters, determined in advance. In this exercise the number of clusters has been determined arbitrarily. This number of clusters should be determined according to the context and goal of your analysis, or based on methods explained in this [section](/blog/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r/#optimal-number-of-clusters). Calling `print(model$cluster)` or `model$cluster` is the same. This output specifies the group (i.e., 1 or 2) to which each country belongs to.

The cluster for each observation can be stored directly in the dataset as a column:

```{r}
Eurojobs_cluster <- data.frame(Eurojobs,
  cluster = as.factor(model$cluster)
)
head(Eurojobs_cluster)
```

### Quality of a *k*-means partition

The quality of a *k*-means partition is found by calculating the percentage of the *TSS* "explained" by the partition using the following formula:

\begin{equation}
\dfrac{\operatorname{BSS}}{\operatorname{TSS}} \times 100\%
\end{equation}

where *BSS* and *TSS* stand for *Between Sum of Squares* and *Total Sum of Squares*, respectively. The higher the percentage, the better the score (and thus the quality) because it means that *BSS* is large and/or *WSS* is small.

Here is how you can check the quality of the partition in R:

```{r}
# BSS and TSS are extracted from the model and stored
(BSS <- model$betweenss)
(TSS <- model$totss)

# We calculate the quality of the partition
BSS / TSS * 100
```

The quality of the partition is `r round(BSS / TSS * 100, 2)`%. This value has no real interpretation in absolute terms except that a higher quality means a higher explained percentage. However, it is more insightful when it is compared to the quality of other partitions (with the same number of clusters!) in order to determine the best partition among the ones considered.

### `nstart` for several initial centers and better stability

The *k*-means algorithm uses a random set of initial points to arrive at the final classification. Due to the fact that the initial centers are randomly chosen, the same command `kmeans(Eurojobs, centers = 2)` may give different results every time it is run, and thus slight differences in the quality of the partitions. The `nstart` argument in the `kmeans()` function allows to run the algorithm several times with different initial centers, in order to obtain a potentially better partition:

```{r, echo = FALSE}
set.seed(42)
```

```{r}
model2 <- kmeans(Eurojobs, centers = 2, nstart = 10)
100 * model2$betweenss / model2$totss
```

Depending on the initial random choices, this new partition will be better or not compared to the first one. In our example, the partition is better as the quality increased to `r round(100 * model2$betweenss / model2$totss, 2)`%.

One of the main limitation often cited regarding *k*-means is the stability of the results. As the initial centers are randomly chosen, running the same command may yield different results. Adding the `nstart` argument in the `kmeans()` function limits this issue as it will generate several different initializations and take the most optimal one, leading to a better stability of the classification.

### `kmeans()` with 3 groups

We now perform the *k*-means classification with 3 clusters and compute its quality:

```{r, echo = FALSE}
set.seed(42)
```

```{r}
model3 <- kmeans(Eurojobs, centers = 3)
BSS3 <- model3$betweenss
TSS3 <- model3$totss
BSS3 / TSS3 * 100
```

It can be seen that the classification into three groups allows for a higher explained percentage and a higher quality. This will always be the case: with more classes, the partition will be finer, and the *BSS* contribution will be higher. On the other hand, the "model" will be more complex, requiring more classes. In the extreme case where *k = n* (each observation is a singleton class), we have *BSS = TSS*, but the partition has lost all interest.

### Optimal number of clusters

In order to find the optimal number of clusters for a *k*-means, it is recommended to choose it based on:

* the context of the problem at hand, for instance if you know that there is a specific number of groups in your data (this is option is however subjective), or
* the following four approaches:
  1. Elbow method (which uses the within cluster sums of squares)
  1. Average silhouette method
  1. Gap statistic method
  1. `NbClust()` function

We show the R code for these 4 methods below, more theoretical information can be found [here](https://www.datanovia.com/en/lessons/determining-the-optimal-number-of-clusters-3-must-know-methods/){target="_blank"}.

#### Elbow method

The Elbow method looks at the total within-cluster sum of square (WSS) as a function of the number of clusters.

```{r, warning = FALSE, message = FALSE}
# load required packages
library(factoextra)
library(NbClust)

# Elbow method
fviz_nbclust(Eurojobs, kmeans, method = "wss") +
  geom_vline(xintercept = 4, linetype = 2) + # add line for better visualisation
  labs(subtitle = "Elbow method") # add subtitle
```

The location of a knee in the plot is usually considered as an indicator of the appropriate number of clusters because it means that adding another cluster does not improve much better the partition. This method seems to suggest 4 clusters.

The Elbow method is sometimes ambiguous and an alternative is the average silhouette method.

#### Silhouette method

The Silhouette method measures the quality of a clustering and determines how well each point lies within its cluster.

```{r}
# Silhouette method
fviz_nbclust(Eurojobs, kmeans, method = "silhouette") +
  labs(subtitle = "Silhouette method")
```

The Silhouette method suggests 2 clusters.

#### Gap statistic method

```{r}
# Gap statistic
set.seed(42)
fviz_nbclust(Eurojobs, kmeans,
  nstart = 25,
  method = "gap_stat",
  nboot = 500
) + # reduce it for lower computation time (but less precise results)
  labs(subtitle = "Gap statistic method")
```

The optimal number of clusters is the one that maximizes the gap statistic. This method suggests only 1 cluster (which is therefore a useless clustering).

As you can see these three methods do not necessarily lead to the same result. Here, all 3 approaches suggest a different number of clusters.

#### `NbClust()`

A fourth alternative is to use the `NbClust()` function, which provides 30 indices for choosing the best number of clusters.

```{r, warning = FALSE}
nbclust_out <- NbClust(
  data = Eurojobs,
  distance = "euclidean",
  min.nc = 2, # minimum number of clusters
  max.nc = 5, # maximum number of clusters
  method = "kmeans" # one of: "ward.D", "ward.D2", "single", "complete", "average", "mcquitty", "median", "centroid", "kmeans"
)

# create a dataframe of the optimal number of clusters
nbclust_plot <- data.frame(clusters = nbclust_out$Best.nc[1, ])
# select only indices which select between 2 and 5 clusters
nbclust_plot <- subset(nbclust_plot, clusters >= 2 & clusters <= 5)

# create plot
ggplot(nbclust_plot) +
  aes(x = clusters) +
  geom_histogram(bins = 30L, fill = "#0c4c8a") +
  labs(x = "Number of clusters", y = "Frequency among all indices", title = "Optimal number of clusters") +
  theme_minimal()
```

Based on all 30 indices, the best number of clusters is 3 clusters.

(See the article "[Graphics in R with ggplot2](/blog/graphics-in-r-with-ggplot2/)" to learn how to create this kind of plot in `{ggplot2}`).

### Visualizations

It is also possible to plot clusters by using the `fviz_cluster()` function. Note that a principal component analysis is performed to represent the variables in a 2 dimensions plane.

We visualize the data in 2 clusters, as suggested by the average silhouette method.

```{r, warning = FALSE, message = FALSE}
library(factoextra)

km_res <- kmeans(Eurojobs, centers = 2, nstart = 20)
fviz_cluster(km_res, Eurojobs, ellipse.type = "norm")
```

Now that the *k*-means clustering has been detailed in R, see how to do the algorithm by hand in the following sections.

### Manual application and verification in R

Perform **by hand** the *k*-means algorithm for the points shown in the graph below, with *k* = 2 and with the points *i* = 5 and *i* = 6 as initial centers. Compute the quality of the partition you just found and then **check** your answers **in R**.

*Assume that the variables have the same units so there is no need to scale the data.*

```{r, echo = FALSE}
set.seed(seed = 2018 * 02 * 15)
n <- 6

all.points.different <- FALSE
while (!all.points.different) {
  X <- matrix(round(rnorm(n * 2, mean = 4, sd = 2)), nrow = n)
  all.points.different <- all(apply(X, MARGIN = 2, FUN = function(x) length(unique(x)) == n))
}
row.names(X) <- 1:n
centres <- X[c(5, 6), ]

pretty.plot <-
  function(X) {
    plot(X,
      asp = 1, xlab = "x", ylab = "y",
      xlim = c(min(X) - 1, max(X) + 1), ylim = c(min(X) - 1, max(X) + 1)
    )
    axis(side = 1, at = min(X):max(X))
    axis(side = 2, at = min(X):max(X))
    for (z in (min(X) - 1):(max(X) + 1)) {
      abline(h = z, lwd = 2, col = "gray", lty = "dotted")
      abline(v = z, lwd = 2, col = "gray", lty = "dotted")
    }
    text(X, labels = row.names(X), pos = 1, cex = 1.5)
  }

pretty.plot(X)
points(centres, pch = 8)
```

#### Solution by hand

Step 1. Here are the coordinates of the 6 points:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1">point</th>
    <th class="tg-cly1">x</th>
    <th class="tg-cly1">y</th>
  </tr>
  <tr>
    <td class="tg-cly1">1</td>
    <td class="tg-cly1">7</td>
    <td class="tg-cly1">3</td>
  </tr>
  <tr>
    <td class="tg-cly1">2</td>
    <td class="tg-cly1">4</td>
    <td class="tg-cly1">5</td>
  </tr>
  <tr>
    <td class="tg-0lax">3</td>
    <td class="tg-0lax">2</td>
    <td class="tg-0lax">4</td>
  </tr>
  <tr>
    <td class="tg-0lax">4</td>
    <td class="tg-0lax">0</td>
    <td class="tg-0lax">1</td>
  </tr>
  <tr>
    <td class="tg-0lax">5</td>
    <td class="tg-0lax">9</td>
    <td class="tg-0lax">7</td>
  </tr>
  <tr>
    <td class="tg-0lax">6</td>
    <td class="tg-0lax">6</td>
    <td class="tg-0lax">8</td>
  </tr>
</table>
</center>
<br>

And the initial centers:

* Group 1: point 5 with center *(9, 7)*
* Group 2: point 6 with center *(6, 8)*

Step 2. Compute the distance matrix point by point with the Pythagorean theorem. Remind that the distance between point *a* and point *b* is found with:

$$\sqrt{(x_a - x_b)^2 + (y_a - y_b)^2}$$

We apply this theorem to each pair of points, to finally have the following distance matrix (rounded to two decimals):

```{r}
round(dist(X), 2)
```

Step 3. Based on the distance matrix computed in step 2, we can put each point to its closest group and compute the coordinates of the center.

We first put each point in its closest group:

* point 1 is closer to point 5 than to point 6 because the distance between points 1 and 5 is 4.47 while the distance between points 1 and 6 is 5.10
* point 2 is closer to point 6 than to point 5 because the distance between points 2 and 5 is 5.39 while the distance between points 2 and 6 is 3.61
* point 3 is closer to point 6 than to point 5 because the distance between points 3 and 5 is 7.62 while the distance between points 3 and 6 is 5.66
* point 4 is closer to point 6 than to point 5 because the distance between points 4 and 5 is 10.82 while the distance between points 4 and 6 is 9.22

Note that computing the distances between each point and the points 5 and 6 is sufficient. There is no need to compute the distance between the points 1 and 2 for example, as we compare each point to the initial centers (which are points 5 and 6).

We then compute the coordinates of the centers of the two groups by taking the mean of the coordinates *x* and *y*:

* Group 1 includes the points 5 and 1 with *(8, 5)* as center ($8 = \frac{9+7}{2}$ and $5 = \frac{7+3}{2}$)
* Group 2 includes the points 6, 2, 3 and 4 with *(3, 4.5)* as center ($3 = \frac{6+4+2+0}{4}$ and $4.5 = \frac{8+5+4+1}{4}$)

We thus have:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">points</th>
    <th class="tg-cly1">center</th>
  </tr>
  <tr>
    <td class="tg-cly1">cluster 1</td>
    <td class="tg-cly1">5 &amp; 1</td>
    <td class="tg-cly1">(8, 5)</td>
  </tr>
  <tr>
    <td class="tg-0lax">cluster 2</td>
    <td class="tg-0lax">6, 2, 3 &amp; 4</td>
    <td class="tg-0lax">(3, 4.5)</td>
  </tr>
</table>
</center>
<br>

Step 4. We make sure that the allocation is optimal by checking that each point is in the nearest cluster. The distance between a point and the center of a cluster is again computed thanks to the Pythagorean theorem. Thus, we have:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-scde{color:#009901;text-align:left;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
.tg .tg-yi9q{color:#009901;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1">points</th>
    <th class="tg-cly1">Distance to cluster 1</th>
    <th class="tg-cly1">Distance to cluster 2</th>
  </tr>
  <tr>
    <td class="tg-cly1">1</td>
    <td class="tg-scde">2.24</td>
    <td class="tg-cly1">4.27</td>
  </tr>
  <tr>
    <td class="tg-cly1">2</td>
    <td class="tg-cly1">4</td>
    <td class="tg-scde">1.12</td>
  </tr>
  <tr>
    <td class="tg-0lax">3</td>
    <td class="tg-0lax">6.08</td>
    <td class="tg-yi9q">1.12</td>
  </tr>
  <tr>
    <td class="tg-0lax">4</td>
    <td class="tg-0lax">8.94</td>
    <td class="tg-yi9q">4.61</td>
  </tr>
  <tr>
    <td class="tg-0lax">5</td>
    <td class="tg-yi9q">2.24</td>
    <td class="tg-0lax">6.5</td>
  </tr>
  <tr>
    <td class="tg-0lax">6</td>
    <td class="tg-yi9q">3.61</td>
    <td class="tg-0lax">4.61</td>
  </tr>
</table>
</center>
<br>

The minimum distance between the points and the two clusters is colored in green.

We check that each point is in the correct group (i.e., the closest cluster). According to the distance in the table above, point 6 seems to be closer to the cluster 1 than to the cluster 2. Therefore, the allocation is not optimal and point 6 should be reallocated to cluster 1.

Step 5. We compute again the centers of the clusters after this reallocation. The centers are found by taking the mean of the coordinates *x* and *y* of the points belonging to the cluster. We thus have:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">points</th>
    <th class="tg-cly1">center</th>
  </tr>
  <tr>
    <td class="tg-cly1">cluster 1</td>
    <td class="tg-cly1">1, 5 &amp; 6</td>
    <td class="tg-cly1">(7.33, 6)</td>
  </tr>
  <tr>
    <td class="tg-0lax">cluster 2</td>
    <td class="tg-0lax">2, 3 &amp; 4</td>
    <td class="tg-0lax">(2, 3.33)</td>
  </tr>
</table>
</center>
<br>

where, for instance, 3.33 is simply $\frac{5+4+1}{3}$.

Step 6. Repeat step 4 until the allocation is optimal. If the allocation is optimal, the algorithm stops. In our example we have:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-scde{color:#009901;text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1">points</th>
    <th class="tg-cly1">Distance to cluster 1</th>
    <th class="tg-cly1">Distance to cluster 2</th>
  </tr>
  <tr>
    <td class="tg-cly1">1</td>
    <td class="tg-scde">3.02</td>
    <td class="tg-cly1">5.01</td>
  </tr>
  <tr>
    <td class="tg-cly1">2</td>
    <td class="tg-cly1">3.48</td>
    <td class="tg-scde">2.61</td>
  </tr>
  <tr>
    <td class="tg-cly1">3</td>
    <td class="tg-cly1">5.69</td>
    <td class="tg-scde">0.67</td>
  </tr>
  <tr>
    <td class="tg-cly1">4</td>
    <td class="tg-cly1">8.87</td>
    <td class="tg-scde">3.07</td>
  </tr>
  <tr>
    <td class="tg-cly1">5</td>
    <td class="tg-scde">1.95</td>
    <td class="tg-cly1">7.9</td>
  </tr>
  <tr>
    <td class="tg-cly1">6</td>
    <td class="tg-scde">2.4</td>
    <td class="tg-cly1">5.08</td>
  </tr>
</table>
</center>
<br>

All points are correctly allocated to its nearest cluster, so the allocation is optimal and the algorithm stops.

Step 7. State the final partition and the centers. In our example:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">points</th>
    <th class="tg-cly1">center</th>
  </tr>
  <tr>
    <td class="tg-cly1">cluster 1</td>
    <td class="tg-cly1">1, 5 &amp; 6</td>
    <td class="tg-cly1">(7.33, 6)</td>
  </tr>
  <tr>
    <td class="tg-cly1">cluster 2</td>
    <td class="tg-cly1">2, 3 &amp; 4</td>
    <td class="tg-cly1">(2, 3.33)</td>
  </tr>
</table>
</center>
<br>

Now that we have the clusters and the final centers, we compute the quality of the partition we just found. Remember that we need to compute the BSS and TSS to find the quality. Below the steps to compute the quality of this partition by *k*-means, based on this summary table:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
.tg .tg-0a7q{border-color:#000000;text-align:left;vertical-align:middle}
.tg .tg-73oq{border-color:#000000;text-align:left;vertical-align:top}
</style>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0pky" colspan="3">cluster 1</th>
    <th class="tg-0pky" colspan="3">cluster 2</th>
  </tr>
  <tr>
    <td class="tg-0pky">point</td>
    <td class="tg-0pky">x</td>
    <td class="tg-0pky">y</td>
    <td class="tg-0pky">point</td>
    <td class="tg-0pky">x</td>
    <td class="tg-0pky">y</td>
  </tr>
  <tr>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">7</td>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">4</td>
    <td class="tg-0pky">5</td>
  </tr>
  <tr>
    <td class="tg-0pky">5</td>
    <td class="tg-0pky">9</td>
    <td class="tg-0pky">7</td>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">4</td>
  </tr>
  <tr>
    <td class="tg-0pky">6</td>
    <td class="tg-0pky">6</td>
    <td class="tg-0pky">8</td>
    <td class="tg-0pky">4</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">1</td>
  </tr>
  <tr>
    <td class="tg-0pky">mean</td>
    <td class="tg-0pky">7.33</td>
    <td class="tg-0pky">6</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">3.33</td>
  </tr>
</table>
</center>
<br>

Step 1. Compute the overall mean of the *x* and *y* coordinates:

$$\overline{\overline{x}} = \frac{7+4+2+0+9+6+3+5+4+1+7+8}{12} \\ = 4.67$$

Step 2. Compute TSS and WSS:

$$TSS = (7-4.67)^2 + (4-4.67)^2 + (2-4.67)^2 \\ + (0-4.67)^2 + (9-4.67)^2 + (6-4.67)^2 \\ + (3-4.67)^2 + (5-4.67)^2 + (4-4.67)^2 \\ + (1-4.67)^2 + (7-4.67)^2 + (8-4.67)^2 \\ = 88.67$$

Regarding WSS, it is splitted between cluster 1 and cluster 2. For cluster 1:

$$WSS[1] = (7-7.33)^2 + (9 - 7.33)^2 + (6 - 7.33)^2 \\ + (3-6)^2 + (7-6)^2 + (8-6)^2 \\ = 18.67$$

For cluster 2:

$$WSS[2] = (4-2)^2 + (2-2)^2 + (0-2)^2 \\ + (5-3.33)^2 + (4-3.33)^2 + (1-3.33)^2 \\ = 16.67$$

And the total WSS is

$$WSS = WSS[1] + WSS[2] = 18.67 + 16.67 \\ = 35.34$$

To find the BSS:

$$BSS = TSS - WSS = 88.67-35.34 \\ = 53.33$$

Finally, the quality of the partition is:

$$Quality = \frac{BSS}{TSS} = \frac{53.33}{88.67} = 0.6014$$

So the quality of the partition is 60.14%.

We are now going to verify all these solutions (the partition, the final centers and the quality) in R.

#### Solution in R

As you can imagine, the solution in R us much shorter and requires much less computation on the user side. We first need to enter the data as a matrix or dataframe:

```{r}
X <- matrix(c(7, 3, 4, 5, 2, 4, 0, 1, 9, 7, 6, 8),
  nrow = 6, byrow = TRUE
)
X # display the coordinates of the points
```

We now perform the *k*-means via the `kmeans()` function with the point 5 and 6 as initial centers:

```{r}
# take rows 5 and 6 of the X matrix as initial centers
res.k <- kmeans(X,
  centers = X[c(5, 6), ],
  algorithm = "Lloyd"
)
```

Unlike in the previous application with the dataset `Eurojobs.csv` where the initial centers are randomly chosen by R, in this second application we want to specify which points are going to be the two initial centers. For this, we need to set `centers = X[c(5,6), ]` to indicate that that there are 2 centers, and that they are going to be the points 5 and 6 (see a reminder on [how to subset a dataframe](/blog/data-manipulation-in-r/) if needed).

The reason for adding the argument `algorithm = "Lloyd"` can be found in the usage of the R function `kmeans()`. In fact, there are several variants of the *k*-means algorithm. The default choice is the @jaaw28m version, which is more sophisticated than the basic version detailed in the solution by hand. By using the original version of @lloyd1982least, we find the same solution in R and by hand. For more information, you can consult the documentation of the `kmeans()` function (via `?kmeans` or `help(kmeans)`) and read the articles mentioned.

The solution in R is then found by extracting

* the partition with `$cluster`:

```{r}
res.k$cluster
```

Points 1, 5 and 6 belong to cluster 1, points 2, 3 and 4 belong to cluster 2.

* the coordinates of the final centers with `$centers`:

```{r}
# We extract the coordinates of the 2 final centers, rounded to 2 decimals
round(res.k$centers, digits = 2)
```

* and then the quality of the partition by dividing the BSS to the TSS:

```{r}
res.k$betweenss / res.k$totss
```

The 3 results are equal to what we found by hand (except the quality which is slightly different due to rounding).

# Hierarchical clustering

Remind that the difference with the partition by *k*-means is that for hierarchical clustering, the number of classes is **not** specified in advance. Hierarchical clustering will help to determine the optimal number of clusters.

Before applying hierarchical clustering by hand and in R, let's see how it works step by step:

1. It starts by putting every point in its own cluster, so each cluster is a singleton
2. It then merges the 2 points that are closest to each other based on the distances from the distance matrix. The consequence is that there is one less cluster
3. It then recalculates the distances between the new and old clusters and save them in a new distance matrix which will be used in the next step
4. Finally, steps 1 and 2 are repeated until all clusters are merged into one single cluster including all points.

There exists 5 main methods to measure the distance between clusters, referred as linkage methods:

1. Single linkage: computes the minimum distance between clusters before merging them.
1. Complete linkage: computes the maximum distance between clusters before merging them.
1. Average linkage: computes the average distance between clusters before merging them.
1. Centroid linkage: calculates centroids for both clusters, then computes the distance between the two before merging them.
1. Ward's (minimum variance) criterion: minimizes the total within-cluster variance and find the pair of clusters that leads to minimum increase in total within-cluster variance after merging.

In the following sections, only the three first linkage methods are presented (first by hand and then the results are verified in R).

## Application 3: hierarchical clustering

### Data

Using the data from the graph and the table below, perform **by hand** the 3 algorithms (single, complete and average linkage) and draw the dendrograms. Then **check** your answers **in R**.

```{r, echo = FALSE}
n <- 5
set.seed(seed = 2018 * 02 * 13)
X <- as.data.frame(round(matrix(data = rnorm(2 * n), nrow = n, byrow = TRUE), 2))
plot(X, asp = 1)
text(X, labels = 1:5, pos = 3, cex = 1.5)
X
```

*Assume that the variables have the same units so there is no need to scale the data.*

### Solution by hand

Step 1. For all 3 algorithms, we first need to compute the distance matrix between the 5 points thanks to the Pythagorean theorem. Remind that the distance between point *a* and point *b* is found with:

$$\sqrt{(x_a - x_b)^2 + (y_a - y_b)^2}$$

We apply this theorem to each pair of points, to finally have the following distance matrix (rounded to three decimals):

```{r, echo = FALSE}
round(dist(X), 3)
```

#### Single linkage

Step 2. From the distance matrix computed in step 1, we see that the **smallest distance** = 0.328 between points 2 and 4. 0.328 corresponds to the first height (more on this later when drawing the dendrogram). Since points 2 and 4 are the closest to each other, these 2 points are put together to form a single group. The groups are thus: 1, 2 & 4, 3 and 5. The new distances between the group 2 & 4 and all other points are now:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0pky"></th>
    <th class="tg-0pky">1</th>
    <th class="tg-0pky">2 &amp; 4</th>
    <th class="tg-0pky">3</th>
    <th class="tg-0pky">5</th>
  </tr>
  <tr>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">2 &amp; 4</td>
    <td class="tg-0pky">2.390</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">2.520</td>
    <td class="tg-0pky">0.483</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">5</td>
    <td class="tg-0pky">0.942</td>
    <td class="tg-0pky">1.530</td>
    <td class="tg-0pky">1.801</td>
    <td class="tg-0pky">0</td>
  </tr>
</table>
</center>
<br>

To construct this new distance matrix, proceed point by point:

* the distance between points 1 and 3 has not changed, so the distance is unchanged compared to the initial distance matrix (found in step 1), which was 2.520
* same goes for the distance between points 1 and 5 and points 3 and 5; the distances are the same than in the initial distance matrix since the points have not changed
* the distance between points 1 and 2 & 4 has changed since points 2 & 4 are now together
* since we are applying the **single linkage** criterion, the new distance between points 1 and 2 & 4 corresponds to the **minimum distance** between the distance between points 1 and 2 and the distance between points 1 and 4
* the initial distance between points 1 and 2 is 2.675 and the initial distance between points 1 and 4 is 2.390
* therefore, the minimum distance between these two distances is 2.390
* 2.390 is thus the new distance between points 1 and 2 & 4
* we apply the same process for points 3 and 2 & 4: the initial distance between points 3 and 2 is 0.483 and the initial distance between points 3 and 4 is 0.603. The minimum distance between these 2 distances is 0.483 so the new distance between points 3 and 2 & 4 is 0.483
* follow the same process for all other points

Step 3. Based on the distance matrix in step 2, the smallest distance is 0.483 between points 3 and 2 & 4 (the second height for the dendrogram). Since points 3 and 2 & 4 are the closest to each other, they are combined to form a new group, the group 2 & 3 & 4. The groups are thus: 1, 2 & 3 & 4 and 5. We construct the new distance matrix based on the same process detailed in step 2:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">1</th>
    <th class="tg-cly1">2 &amp; 3 &amp; 4</th>
    <th class="tg-cly1">5</th>
  </tr>
  <tr>
    <td class="tg-cly1">1</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">2 &amp; 3 &amp; 4</td>
    <td class="tg-cly1">2.390</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">5</td>
    <td class="tg-cly1">0.942</td>
    <td class="tg-cly1">1.530</td>
    <td class="tg-cly1">0</td>
  </tr>
</table>
</center>
<br>

* points 1 and 5 have not change, so the distance between these two points are the same than in previous step
* from step 2 we see that the distance between points 1 and 2 & 4 is 2.390 and the distance between points 1 and 3 is 2.520
* since we apply the single linkage criterion, we take the minimum distance, which is 2.390
* the distance between points 1 and 2 & 3 & 4 is thus 2.390
* same process for points 5 and 2 & 3 & 4

Step 4. Based on the distance matrix in step 3, the smallest distance is 0.942 between points 1 and 5 (the third height in the dendrogram). Since points 1 and 5 are the closest to each other, they are combined to form a new group, the group 1 & 5. The groups are thus: 1 & 5 and 2 & 3 & 4. We construct the new distance matrix based on the same process detailed in steps 2 and 3:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">1 &amp; 5</th>
    <th class="tg-cly1">2 &amp; 3 &amp; 4</th>
  </tr>
  <tr>
    <td class="tg-cly1">1 &amp; 5</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">2 &amp; 3 &amp; 4</td>
    <td class="tg-cly1">1.530</td>
    <td class="tg-cly1">0</td>
  </tr>
</table>
</center>
<br>

* the only distance left to compute is the distance between points 1 & 5 and 2 & 3 & 4
* from the previous step we see that the distance between points 1 and 2 & 3 & 4 is 2.390 and the distance between points 5 and 2 & 3 & 4 is 1.530
* since we apply the single linkage criterion, we take the minimum distance, which is 1.530
* the distance between points 1 & 5 and 2 & 3 & 4 is thus 1.530

Step 5. The final combination of points is the combination of points 1 & 5 and 2 & 3 & 4, with a final height of 1.530. Heights are used to draw the dendrogram in the sixth and final step.

Step 6. Draw the dendrogram thanks to the combination of points and heights found above. Remember that:

* the first combination of points was between points 2 and 4, with a height of 0.328
* the second combination was between points 3 and 2 & 4 with a height of 0.483
* the third combination was between points 1 and 5 with a height of 0.942
* the final combination was between points 1 & 5 and 2 & 3 & 4 with a height of 1.530
* this is exactly what is illustrated in the following dendrogram:

```{r, echo = FALSE}
hclust <- hclust(dist(X), method = "single")
plot(hclust)
```

In hierarchical clustering, dendrograms are used to show the sequence of combinations of the clusters. The distances of merge between clusters, called heights, are illustrated on the y-axis.

#### Complete linkage

Complete linkage is quite similar to single linkage, except that instead of taking the smallest distance when computing the new distance between points that have been grouped, the **maximum distance** is taken.

The steps to perform the hierarchical clustering with the complete linkage (maximum) are detailed below.

Step 1. Step 1 is exactly the same than for single linkage, that is, we compute the distance matrix of the 5 points thanks to the Pythagorean theorem. This gives us the following distance matrix:

```{r, echo = FALSE}
round(dist(X), 3)
```

Step 2. From the distance matrix computed in step 1, we see that the **smallest distance** = 0.328 between points 2 and 4. It is important to note that even if we apply the complete linkage, in the distance matrix the points are brought together based on the smallest distance. This is the case for all 3 algorithms. The difference between the 3 algorithms lies in how to compute the new distances between the new combination of points (the single linkage takes the minimum between the distances, the complete linkage takes the maximum distance and the average linkage takes the average distance). 0.328 corresponds to the first height (which will be used when drawing the dendrogram). Since points 2 and 4 are the closest to each other, these 2 points are put together to form a single group. The groups are thus: 1, 2 & 4, 3 and 5. The new distances between the group 2 & 4 and all other points are now:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0pky"></th>
    <th class="tg-0pky">1</th>
    <th class="tg-0pky">2 &amp; 4</th>
    <th class="tg-0pky">3</th>
    <th class="tg-0pky">5</th>
  </tr>
  <tr>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">2 &amp; 4</td>
    <td class="tg-0pky">2.675</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">2.520</td>
    <td class="tg-0pky">0.603</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">5</td>
    <td class="tg-0pky">0.942</td>
    <td class="tg-0pky">1.841</td>
    <td class="tg-0pky">1.801</td>
    <td class="tg-0pky">0</td>
  </tr>
</table>
</center>
<br>

To construct this new distance matrix, proceed point by point as we did for single linkage:

* the distance between points 1 and 3 has not changed, so the distance is unchanged compared to the initial distance matrix (found in step 1), which was 2.520
* same goes for the distance between points 1 and 5 and points 3 and 5; the distances are the same than in the initial distance matrix since the points have not changed
* the distance between points 1 and 2 & 4 has changed since points 2 & 4 are now together
* since we are applying the **complete linkage** criterion, the new distance between points 1 and 2 & 4 corresponds to the **maximum distance** between the distance between points 1 and 2 and the distance between points 1 and 4
* the initial distance between points 1 and 2 is 2.675 and the initial distance between points 1 and 4 is 2.390
* therefore, the maximum distance between these two distances is 2.675
* 2.675 is thus the new distance between points 1 and 2 & 4
* we apply the same process for points 3 and 2 & 4: the initial distance between points 3 and 2 is 0.483 and the initial distance between points 3 and 4 is 0.603. The maximum distance between these 2 distances is 0.603 so the new distance between points 3 and 2 & 4 is 0.603
* follow the same process for all other points

Step 3. Based on the distance matrix in step 2, the smallest distance is 0.603 between points 3 and 2 & 4 (the second height for the dendrogram). Since points 3 and 2 & 4 are the closest to each other, they are combined to form a new group, the group 2 & 3 & 4. The groups are thus: 1, 2 & 3 & 4 and 5. We construct the new distance matrix based on the same process detailed in step 2:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">1</th>
    <th class="tg-cly1">2 &amp; 3 &amp; 4</th>
    <th class="tg-cly1">5</th>
  </tr>
  <tr>
    <td class="tg-cly1">1</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">2 &amp; 3 &amp; 4</td>
    <td class="tg-cly1">2.675</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">5</td>
    <td class="tg-cly1">0.942</td>
    <td class="tg-cly1">1.841</td>
    <td class="tg-cly1">0</td>
  </tr>
</table>
</center>
<br>

* points 1 and 5 have not change, so the distance between these two points are the same than in previous step
* from step 2 we see that the distance between points 1 and 2 & 4 is 2.675 and the distance between points 1 and 3 is 2.520
* since we apply the complete linkage criterion, we take the maximum distance, which is 2.675
* the distance between points 1 and 2 & 3 & 4 is thus 2.675
* same process for points 5 and 2 & 3 & 4

Step 4. Based on the distance matrix in step 3, the smallest distance is 0.942 between points 1 and 5 (the third height in the dendrogram). Since points 1 and 5 are the closest to each other, they are combined to form a new group, the group 1 & 5. The groups are thus: 1 & 5 and 2 & 3 & 4. We construct the new distance matrix based on the same process detailed in steps 2 and 3:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">1 &amp; 5</th>
    <th class="tg-cly1">2 &amp; 3 &amp; 4</th>
  </tr>
  <tr>
    <td class="tg-cly1">1 &amp; 5</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">2 &amp; 3 &amp; 4</td>
    <td class="tg-cly1">2.675</td>
    <td class="tg-cly1">0</td>
  </tr>
</table>
</center>
<br>

* the only distance left to compute is the distance between points 1 & 5 and 2 & 3 & 4
* from the previous step we see that the distance between points 1 and 2 & 3 & 4 is 2.675 and the distance between points 5 and 2 & 3 & 4 is 1.841
* since we apply the complete linkage criterion, we take the maximum distance, which is 2.675
* the distance between points 1 & 5 and 2 & 3 & 4 is thus 2.675

Step 5. The final combination of points is the combination of points 1 & 5 and 2 & 3 & 4, with a final height of 2.675. Heights are used to draw the dendrogram in the sixth and final step.

Step 6. Draw the dendrogram thanks to the combination of points and heights found above. Remember that:

* the first combination of points was between points 2 and 4, with a height of 0.328
* the second combination was between points 3 and 2 & 4 with a height of 0.603
* the third combination was between points 1 and 5 with a height of 0.942
* the final combination was between points 1 & 5 and 2 & 3 & 4 with a height of 2.675
* this is exactly what is illustrated in the following dendrogram:

```{r, echo = FALSE}
hclust <- hclust(dist(X), method = "complete")
plot(hclust)
```

#### Average linkage

With the average linkage criterion, it is not the minimum nor the maximum distance that is taken when computing the new distance between points that have been grouped, but it is, as you guessed by now, the **average distance** between the points.

The steps to perform the hierarchical clustering with the average linkage are detailed below.

Step 1. Step 1 is exactly the same than for single and complete linkage, that is, we compute the distance matrix of the 5 points thanks to the Pythagorean theorem. This gives us the following distance matrix:

```{r, echo = FALSE}
round(dist(X), 3)
```

Step 2. From the distance matrix computed in step 1, we see that the **smallest distance** = 0.328 between points 2 and 4. It is important to note that even if we apply the average linkage, in the distance matrix the points are brought together based on the smallest distance. This is the case for all 3 algorithms. The difference between the 3 algorithms lies in how to compute the new distances between the new combination of points (the single linkage takes the minimum between the distances, the complete linkage takes the maximum distance and the average linkage takes the average distance). 0.328 corresponds to the first height (which will be used when drawing the dendrogram). Since points 2 and 4 are the closest to each other, these 2 points are put together to form a single group. The groups are thus: 1, 2 & 4, 3 and 5. The new distances between the group 2 & 4 and all other points are now:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0pky"></th>
    <th class="tg-0pky">1</th>
    <th class="tg-0pky">2 &amp; 4</th>
    <th class="tg-0pky">3</th>
    <th class="tg-0pky">5</th>
  </tr>
  <tr>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">2 &amp; 4</td>
    <td class="tg-0pky">2.5325</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">2.520</td>
    <td class="tg-0pky">0.543</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">5</td>
    <td class="tg-0pky">0.942</td>
    <td class="tg-0pky">1.6855</td>
    <td class="tg-0pky">1.801</td>
    <td class="tg-0pky">0</td>
  </tr>
</table>
</center>
<br>

To construct this new distance matrix, proceed point by point as we did for the two previous criteria:

* the distance between points 1 and 3 has not changed, so the distance is unchanged compared to the initial distance matrix (found in step 1), which was 2.520
* same goes for the distance between points 1 and 5 and points 3 and 5; the distances are the same than in the initial distance matrix since the points have not changed
* the distance between points 1 and 2 & 4 has changed since points 2 & 4 are now together
* since we are applying the **average linkage** criterion, the new distance between points 1 and 2 & 4 corresponds to the **average distance** between the distance between points 1 and 2 and the distance between points 1 and 4
* the initial distance between points 1 and 2 is 2.675 and the initial distance between points 1 and 4 is 2.390
* therefore, the average distance between these two distances is $\frac{2.675 + 2.390}{2} = 2.5325$
* 2.5325 is thus the new distance between points 1 and 2 & 4
* we apply the same process for points 3 and 2 & 4: the initial distance between points 3 and 2 is 0.483 and the initial distance between points 3 and 4 is 0.603. The average distance between these 2 distances is 0.543 so the new distance between points 3 and 2 & 4 is 0.543
* follow the same process for all other points

Step 3. Based on the distance matrix in step 2, the smallest distance is 0.543 between points 3 and 2 & 4 (the second height for the dendrogram). Since points 3 and 2 & 4 are the closest to each other, they are combined to form a new group, the group 2 & 3 & 4. The groups are thus: 1, 2 & 3 & 4 and 5. We construct the new distance matrix based on the same process detailed in step 2:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">1</th>
    <th class="tg-cly1">2 &amp; 3 &amp; 4</th>
    <th class="tg-cly1">5</th>
  </tr>
  <tr>
    <td class="tg-cly1">1</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">2 &amp; 3 &amp; 4</td>
    <td class="tg-cly1">2.528333</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">5</td>
    <td class="tg-cly1">0.942</td>
    <td class="tg-cly1">1.724</td>
    <td class="tg-cly1">0</td>
  </tr>
</table>
</center>
<br>

* points 1 and 5 have not change, so the distance between these two points are the same than in previous step
* from step 2 we see that the distance between points 1 and 2 & 4 is 2.5325 and the distance between points 1 and 3 is 2.520
* since we apply the average linkage criterion, we take the average distance
* however, we have to take into the consideration that there are 2 points in the group 2 & 4, while there is only one point in the group 3
* the average distance for the distance between 1 and 2 & 3 & 4 is thus: $\frac{(2 \cdot 2.5325) + (1 \cdot 2.520)}{3} = 2.528333$
* same process for points 5 and 2 & 3 & 4: $\frac{(2 \cdot 1.6855) + (1 \cdot 1.801)}{3} = 1.724$

Step 4. Based on the distance matrix in step 3, the smallest distance is 0.942 between points 1 and 5 (the third height in the dendrogram). Since points 1 and 5 are the closest to each other, they are combined to form a new group, the group 1 & 5. The groups are thus: 1 & 5 and 2 & 3 & 4. We construct the new distance matrix based on the same process detailed in steps 2 and 3:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">1 &amp; 5</th>
    <th class="tg-cly1">2 &amp; 3 &amp; 4</th>
  </tr>
  <tr>
    <td class="tg-cly1">1 &amp; 5</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">2 &amp; 3 &amp; 4</td>
    <td class="tg-cly1">2.126167</td>
    <td class="tg-cly1">0</td>
  </tr>
</table>
</center>
<br>

* the only distance left to compute is the distance between points 1 & 5 and 2 & 3 & 4
* from the previous step we see that the distance between points 1 and 2 & 3 & 4 is 2.528333 and the distance between points 5 and 2 & 3 & 4 is 1.724
* since we apply the average linkage criterion, we take the average distance, which is $\frac{2.528333 + 1.724}{2} = 2.126167$
* the distance between points 1 & 5 and 2 & 3 & 4 is thus 2.126167

Step 5. The final combination of points is the combination of points 1 & 5 and 2 & 3 & 4, with a final height of 2.126167. Heights are used to draw the dendrogram in the sixth and final step.

Step 6. Draw the dendrogram thanks to the combination of points and heights found above. Remember that:

* the first combination of points was between points 2 and 4, with a height of 0.328
* the second combination was between points 3 and 2 & 4 with a height of 0.543
* the third combination was between points 1 and 5 with a height of 0.942
* the final combination was between points 1 & 5 and 2 & 3 & 4 with a height of 2.126167
* this is exactly what is illustrated in the following dendrogram:

```{r, echo = FALSE}
hclust <- hclust(dist(X), method = "average")
plot(hclust)
```

### Solution in R

To perform the hierarchical clustering with any of the 3 criterion in R, we first need to enter the data (in this case as a matrix format, but it can also be entered as a dataframe):

```{r}
X <- matrix(c(2.03, 0.06, -0.64, -0.10, -0.42, -0.53, -0.36, 0.07, 1.14, 0.37),
  nrow = 5, byrow = TRUE
)
```

#### Single linkage

We can apply the hierarchical clustering with the single linkage criterion thanks to the `hclust()` function with the argument `method = "single"`:

```{r}
# Hierarchical clustering: single linkage
hclust <- hclust(dist(X), method = "single")
```

Note that the `hclust()` function requires a distance matrix. If your data is not already a distance matrix (like in our case, as the matrix `X` corresponds to the coordinates of the 5 points), you can transform it into a distance matrix with the `dist()` function.

We can now extract the heights and plot the dendrogram to check our results by hand found above:

```{r}
round(hclust$height, 3)
plot(hclust)
```

As we can see from the dendrogram, the combination of points and the heights are the same than the ones obtained by hand.

##### Optimal number of clusters

Remember that hierarchical clustering is used to determine the optimal number of clusters. This optimal number of clusters can be determined thanks to the dendrogram. For this, we usually look at the largest difference of heights:

![How to determine the number of clusters from a dendrogram? Take the largest difference of heights and count how many vertical lines you see](/blog/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r_files/dendrogram-single-linkage.png)

The largest difference of heights in the dendrogram occurs before the final combination, that is, before the combination of the group 2 & 3 & 4 with the group 1 & 5. To determine the optimal number of clusters, simply count how many vertical lines you see within this largest difference. In our case, the optimal number of clusters is thus 2.

In R, we can even highlight these two clusters directly in the dendrogram with the `rect.hclust()` function:

```{r}
plot(hclust)
rect.hclust(hclust,
  k = 2, # k is used to specify the number of clusters
  border = "blue"
)
```

Note that determining the optimal number of clusters via the dendrogram is not specific to the single linkage, it can be applied to other linkage methods too!

Below another figure explaining how to determine the optimal number of clusters:

![How to determine the optimal numbers of cluster in hierarchical clustering? Source: Towards Data Science](/blog/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r_files/optimal number of clusters hierarchical clustering.png){width=100%}

(See this [hierarchical clustering cheatsheet](/blog/files/Hierarchical-clustering-cheatsheet.pdf) for more visualizations like this.)

Finally, we could also determine the optimal number of cluster thanks to a barplot of the heights (stored in `$height` of the clustering output):

```{r}
barplot(hclust$height,
  names.arg = (nrow(X) - 1):1 # show the number of cluster below each bars
)
```

Again, look for the largest jump of heights. In our case, the largest jump is from 1 to 2 classes. Therefore, the optimal number of classes is 2.

Note that determining the number of clusters using the dendrogram or barplot is not a strict rule. You can also consider other methods such as the _silhouette plot_, _elbow plot_ or some numerical measures like Dunn's index, Hubert's gamma, etc., which show the variation of the error with the number of clusters (*k*), and you choose the value of *k* where the error is smallest. Furthermore, measuring the goodness of clusters can be done thanks to the Dunn's Index (the higher the index, the better). However, these methods are beyond the scope of this course and the method presented with the dendrogram is generally sufficient.

#### Complete linkage

We can apply the hierarchical clustering with the complete linkage criterion thanks to the `hclust()` function with the argument `method = "complete"`:

```{r}
# Hierarchical clustering: complete linkage
hclust <- hclust(dist(X), method = "complete")
```

Note that the `hclust()` function requires a distance matrix. If your data is not already a distance matrix (like in our case, as the matrix `X` corresponds to the coordinates of the 5 points), you can transform it into a distance matrix with the `dist()` function.

We can now extract the heights and plot the dendrogram to check our results by hand found above:

```{r}
round(hclust$height, 3)
plot(hclust)
```

As we can see from the dendrogram, the combination of points and the heights are the same than the ones obtained by hand.

Similar to the single linkage, the largest difference of heights in the dendrogram occurs before the final combination, that is, before the combination of the group 2 & 3 & 4 with the group 1 & 5. In this case, the optimal number of clusters is thus 2. In R, we can even highlight these two clusters directly in the dendrogram with the `rect.hclust()` function:

```{r}
plot(hclust)
rect.hclust(hclust,
  k = 2, # k is used to specify the number of clusters
  border = "blue"
)
```

#### Average linkage

We can apply the hierarchical clustering with the average linkage criterion thanks to the `hclust()` function with the argument `method = "average"`:

```{r}
# Hierarchical clustering: average linkage
hclust <- hclust(dist(X), method = "average")
```

Note that the `hclust()` function requires a distance matrix. If your data is not already a distance matrix (like in our case, as the matrix `X` corresponds to the coordinates of the 5 points), you can transform it into a distance matrix with the `dist()` function.

We can now extract the heights and plot the dendrogram to check our results by hand found above:

```{r}
round(hclust$height, 3)
plot(hclust)
```

As we can see from the dendrogram, the combination of points and the heights are the same than the ones obtained by hand.

Like the single and complete linkages, the largest difference of heights in the dendrogram occurs before the final combination, that is, before the combination of the group 2 & 3 & 4 with the group 1 & 5. In this case, the optimal number of clusters is thus 2. In R, we can even highlight these two clusters directly in the dendrogram with the `rect.hclust()` function:

```{r}
plot(hclust)
rect.hclust(hclust,
  k = 2, # k is used to specify the number of clusters
  border = "blue"
)
```

# *k*-means versus hierarchical clustering

Clustering is rather a subjective statistical analysis and there can be more than one appropriate algorithm, depending on the dataset at hand or the type of problem to be solved. So choosing between *k*-means and hierarchical clustering is not always easy. If you have a good reason to think that there is a specific number of clusters in your dataset (for example if you would like to distinguish diseased and healthy patients depending on some characteristics but you do not know in which group patients belong to), you should probably opt for the *k*-means clustering as this technique is used when the number of groups is specified in advance. If you do not have any reason to believe there is a certain number of groups in your dataset (for instance in marketing when trying to distinguish clients without any prior belief on the number of different types of customers), then you should probably opt for the hierarchical clustering to determine in how many clusters your data should be divided.

In addition to this, if you are still undecided note that, on the one hand, with a large number of variables, *k*-means may be computationally faster than hierarchical clustering if the number of clusters is small. On the other hand, the result of a hierarchical clustering is a structure that is more informative and interpretable than the unstructured set of flat clusters returned by *k*-means. Therefore, it is easier to determine the optimal number of clusters by looking at the dendrogram of a hierarchical clustering than trying to predict this optimal number in advance in case of *k*-means.

Thanks for reading. I hope this article helped you understand the different clustering methods and how to compute them by hand and in R.

As always, if you have a question or a suggestion related to the topic covered in this article, please add it as a comment so other readers can benefit from the discussion.

# References
