---
title: "The complete guide to clustering analysis: k-means and hierarchical clustering by hand and in R"
author: Antoine Soetewey
date: "2020-02-05"
slug: clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r
categories: []
tags:
  - R
  - Statistics
meta_img: blog/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r_files/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r-statsandr.com.jpeg
# description: Description for the page.
output:
  blogdown::html_page:
    toc: true
    toc_depth: 6
draft: true
bibliography: bibliography.bib
---

![Photo by Nikola Johnny Mirkovic](/blog/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r_files/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r-statsandr.com.jpeg){width=100%}

# What is clustering analysis?

Clustering analysis is a form of exploratory data analysis in which observations are divided into different groups that share common characteristics.

The purpose of cluster analysis (also known as classification) is to construct groups (or classes or *clusters*) while ensuring the following property: Within a group the observations must be similar, while the differences between observations belonging to different groups must be significant.

There are two main types of classification:

1. *k*-means clustering
2. Hierarchical clustering

The first is generally used when the **number of classes is fixed** in advance, while the second is generally used for an **unknown number of classes** and helps to determine this optimal number. Both methods are illustrated below through applications by hand and in R. Note that for hierarchical clustering, only the *ascending* classification is presented in this article.

Clustering algorithms use the **distance** in order to separate observations into different groups. Therefore, before diving into the presentation of the two classification methods, a reminder exercise on how to compute distances between points is presented.

## Application 1: Computing distances

Let a data set containing the points $\boldsymbol{a} = (0, 0)'$, $\boldsymbol{b} = (1, 0)'$ and $\boldsymbol{c} = (5, 5)'$. Compute the matrix of Euclidean distances between the points.

### Solution

The points are as follows:

```{r}
# We create the points in R
a <- c(0, 0)
b <- c(1, 0)
c <- c(5, 5)

X <- rbind(a, b, c) # a, b and c are combined per row
colnames(X) <- c("x", "y") # rename columns

X # display the points
```

By the Pythagorean theorem, we will remember that the distance between 2 points $(x_a, y_a)$ and $(x_b, y_b)$ in $\mathbb{R}^2$ is given by $\sqrt{(x_a - x_b)^2 + (y_a - y_b)^2}$. So for instance, for the distance between the points $\boldsymbol{b} = (1, 0)'$ and $\boldsymbol{c} = (5, 5)'$ presented in the statement above, we have :

\begin{equation}
\sqrt{(x_b - x_c)^2 + (y_b - y_c)^2} = \sqrt{(1-5)^2 + (0-5)^2} = 6.403124
\end{equation}

We can proceed similarly for all pairs of points to find the distance matrix by hand. In R, the `dist()` function allows you to find the distance of points in a matrix or dataframe in a very simple way:
 
```{r}
# The distance is found using the dist() function:
distance <- dist(X, method = "euclidean")
distance # display the distance matrix
```

Note that the argument `method = "euclidean"` is not mandatory because the Euclidean method is the default one.

The distance matrix resulting from the `dist()` function gives the distance between the different points. The Euclidean distance between the points $\boldsymbol{b}$ and $\boldsymbol{c}$ is `r round(distance[3], 6)`, which corresponds to what we found above via the Pythagorean formula.

Now that the distance has been presented, let's see how to perform clustering analysis with the k-means algorithm. 

# *k*-means clustering

The first form of classification is the method called _*k*-means clustering_ or the mobile center algorithm. As a reminder, this method aims at partitioning $n$ observations into $k$ clusters in which each observation belongs to the cluster with the closest average, serving as a prototype of the cluster. It is presented below.

## Application 2: *k*-means clustering

### Data

For this exercise, the `Eurojobs.csv` database available [here](/blog/data/Eurojobs.csv) is used.

This database contains the percentage of the population employed in different industries in 26 European countries in 1979. It contains 10 variables:

* `Country` - the name of the country (identifier)
* `Agr` - % of workforce employed in agriculture
* `Min` - % in mining
* `Man` - % in manufacturing
* `PS` - % in power supplies industries
* `Con` - % in construction
* `SI` - % in service industries
* `Fin` - % in finance
* `SPS` - % in social and personal services
* `TC` - % in transportation and communications

We first import the dataset. See [how to import data into R](/blog/how-to-import-an-excel-file-in-rstudio) if you need a reminder.

```{r, warning = FALSE, message = FALSE}
# Import data
Eurojobs <- read.csv(file = "https://www.statsandr.com/blog/data/Eurojobs.csv",
                     sep = ",", dec = ".", header = TRUE)
head(Eurojobs) # head() is used to display only the first 6 observations
```

Note that there is a numbering before the first variable `Country`. For more clarity, we will replace this numbering by the country. To do this, we add the argument `row.names = 1` to the import function `read.csv()` to specify that the first column corresponds to the row names:

```{r}
Eurojobs <- read.csv(
  file = "https://www.statsandr.com/blog/data/Eurojobs.csv",
  sep = ",", dec = ".", header = TRUE, row.names = 1
)
Eurojobs # displays dataset
dim(Eurojobs) # displays the number of rows and columns
```

We now have a "clean" dataset of 26 observations and 9 variables on which we can base the classification. Note that in this case it is not necessary to standardize the data because they are all expressed in the same unit (in percentage). If this was not the case, we would have had to standardize the data via the `scale()` function (see below for an example where the data is standardized before classification). The so-called *k*-means clustering is done via the `kmeans()` function. We apply the classification with 2 classes and then 3 classes.

### `kmeans()` with 2 groups

```{r, echo = FALSE}
set.seed(42)
```


```{r}
model <- kmeans(Eurojobs, centers = 2)

# displays the class determined by
# the model for all observations:
print(model$cluster)
```

Note that the argument `centers = 2` is used to set the number of clusters, determined in advance. In this exercise the number of clusters has been determined arbitrarily. This number of clusters should be determined according to the context and goal of your analysis. Calling `print(model$cluster)` or `model$cluster` is the same. This output specifies the group (*i.e.*, 1 or 2) to which each country belongs.

### Quality of a *k*-means partition

The quality of a partition is found by calculating the percentage of the *TSS* "explained" by the partition using the following formula:

\begin{equation}
\dfrac{\operatorname{BSS}}{\operatorname{TSS}} \times 100\%,
\end{equation}

where *BSS* and *TSS* stands for *Between Sum of Squares* and *Total Sum of Squares*, respectively. The higher the percentage, the better the score because it means that *BSS* is large and/or *WSS* is small.

Here is how you can check the quality of the partition in R:

```{r}
# BSS and TSS are extracted from the model
(BSS <- model$betweenss)
(TSS <- model$totss)

# We calculate the quality of the partition
BSS / TSS * 100
```

The quality of the partition is `r round(BSS / TSS * 100, 2)`%. This value has no real interpretation in absolute terms except that a higher quality means a higher explained percentage. However, it is more insightful when it is compared to the quality of other partitions (with the same number of clusters!) in order to determine the best partition among the ones considered.

### `nstart` for several initial centers

The *k*-means algorithm uses a random set of initial points to arrive at the final classification. Due to the fact that the initial centers are randomly chosen, the same command `kmeans(Eurojobs, centers = 2)` may give slightly different results every tume , and thus slight differences in the quality of the partitions. The `nstart` argument in the `kmeans()` function allows to run the algorithm several times with different initial centers, in order to obtain a potentially better partition:

```{r, echo = FALSE}
set.seed(42)
```

```{r}
model2 <- kmeans(Eurojobs, centers = 2, nstart = 10)
100 * model2$betweenss / model2$totss
```

Depending on the initial random choices, this new partition will be better or not compared to the first one.

### `kmeans()` with 3 groups

```{r, echo = FALSE}
set.seed(42)
```

```{r}
model3 <- kmeans(Eurojobs, centers = 3)
BSS3 <- model3$betweenss
TSS3 <- model3$totss
BSS3 / TSS3 * 100
```

It can be seen that the classification into three groups allows for a higher explained percentage and a higher quality. This will always be the case: with more classes, the partition will be finer, and the *BSS* contribution will be higher. On the other hand, the "model" will be more complex, requiring more classes. In the extreme case where *k = n* (each observation is a singleton class), we have *BSS = TSS*, but the partition has lost all interest.

Now that the *k*-means clustering has been detailed in R, see how to do the algorithm by hand in the following sections.

### Manual application and verification in R

Perform **by hand** the *k*-means algorithm for the points shown in the graph below, with *k* = 2 and with the points *i* = 5 and *i* = 6 as initial centers. Compute the quality of the partition you just found and then **check** your answers **in R**.

```{r, echo = FALSE}
set.seed(seed = 2018 * 02 * 15)
n <- 6

all.points.different <- FALSE
while (!all.points.different) {
  X <- matrix(round(rnorm(n * 2, mean = 4, sd = 2)), nrow = n)
  all.points.different <- all(apply(X, MARGIN = 2, FUN = function(x) length(unique(x)) == n))
}
row.names(X) <- 1:n
centres <- X[c(5,6), ]

pretty.plot <- 
  function(X)
  {
    plot(X, asp = 1, xlab = "x", ylab = "y",
	xlim = c(min(X)-1, max(X)+1), ylim = c(min(X)-1, max(X)+1))
    axis(side = 1, at = min(X):max(X))
    axis(side = 2, at = min(X):max(X))
    for (z in (min(X)-1):(max(X)+1)) {
      abline(h = z, lwd = 2, col = "gray", lty = "dotted")
      abline(v = z, lwd = 2, col = "gray", lty = "dotted")
    }
    text(X, labels = row.names(X), pos = 1, cex = 1.5)
  }

pretty.plot(X)
points(centres, pch = 8)
```

#### Solution by hand

Step 1. Here are the coordinates of the 6 points:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1">point</th>
    <th class="tg-cly1">x</th>
    <th class="tg-cly1">y</th>
  </tr>
  <tr>
    <td class="tg-cly1">1</td>
    <td class="tg-cly1">7</td>
    <td class="tg-cly1">3</td>
  </tr>
  <tr>
    <td class="tg-cly1">2</td>
    <td class="tg-cly1">4</td>
    <td class="tg-cly1">5</td>
  </tr>
  <tr>
    <td class="tg-0lax">3</td>
    <td class="tg-0lax">2</td>
    <td class="tg-0lax">4</td>
  </tr>
  <tr>
    <td class="tg-0lax">4</td>
    <td class="tg-0lax">0</td>
    <td class="tg-0lax">1</td>
  </tr>
  <tr>
    <td class="tg-0lax">5</td>
    <td class="tg-0lax">9</td>
    <td class="tg-0lax">7</td>
  </tr>
  <tr>
    <td class="tg-0lax">6</td>
    <td class="tg-0lax">6</td>
    <td class="tg-0lax">8</td>
  </tr>
</table>
</center>
<br>

And the initial centers:

* Group 1: point 5 with center *(9, 7)*
* Group 2: point 6 with center *(6, 8)*

Step 2. Compute the distance matrix point by point with the Pythagorean theorem. Remind that the distance between the point *a* and the point *b* is found with:

$$\sqrt{(x_a - x_b)^2 + (y_a - y_b)^2}$$

We apply this theorem to each pair of points, to finally have the following distance matrix (rounded to two decimals):

```{r, echo = FALSE}
round(dist(X), 2)
```

Step 3. Based on the distance matrix computed in step 2, we can put each point to its closest group and compute the coordinates of the center.

We first put each point in its closest group:

* point 1 is closer to point 5 than to point 6 because the distance between points 1 and 5 is 4.47 while the distance between points 1 and 6 is 5.10
* point 2 is closer to point 6 than to point 5 because the distance between points 2 and 5 is 5.39 while the distance between points 2 and 6 is 3.61
* point 3 is closer to point 6 than to point 5 because the distance between points 3 and 5 is 7.62 while the distance between points 3 and 6 is 5.66
* point 4 is closer to point 6 than to point 5 because the distance between points 4 and 5 is 10.82 while the distance between points 4 and 6 is 9.22

Note that computing the distances between each point and the points 5 and 6 is sufficient. There is no need to compute the distance between the points 1 and 2 for example, as we compare each point to the initial centers (which are points 5 and 6).

We then compute the coordinates of the centers of the two groups by taking the mean of the coordinates *x* and *y*:

* Group 1 includes the points 5 and 1 with *(8, 5)* as center ($8 = \frac{9+7}{2}$ and $5 = \frac{7+3}{2}$)
* Group 2 includes the points 6, 2, 3 and 4 with *(3, 4.5)* as center ($3 = \frac{6+4+2+0}{4}$ and $4.5 = \frac{8+5+4+1}{4}$)

We thus have:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">points</th>
    <th class="tg-cly1">center</th>
  </tr>
  <tr>
    <td class="tg-cly1">cluster 1</td>
    <td class="tg-cly1">5 &amp; 1</td>
    <td class="tg-cly1">(8, 5)</td>
  </tr>
  <tr>
    <td class="tg-0lax">cluster 2</td>
    <td class="tg-0lax">6, 2, 3 &amp; 4</td>
    <td class="tg-0lax">(3, 4.5)</td>
  </tr>
</table>
</center>
<br>

Step 4. We make sure that the allocation is optimal by checking that each point is in the nearest cluster. The distance between a point and the center of a cluster is again computed thanks to the Pythagorean theorem. Thus, we have:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-scde{color:#009901;text-align:left;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
.tg .tg-yi9q{color:#009901;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1">points</th>
    <th class="tg-cly1">Distance to cluster 1</th>
    <th class="tg-cly1">Distance to cluster 2</th>
  </tr>
  <tr>
    <td class="tg-cly1">1</td>
    <td class="tg-scde">2.24</td>
    <td class="tg-cly1">4.27</td>
  </tr>
  <tr>
    <td class="tg-cly1">2</td>
    <td class="tg-cly1">4</td>
    <td class="tg-scde">1.12</td>
  </tr>
  <tr>
    <td class="tg-0lax">3</td>
    <td class="tg-0lax">6.08</td>
    <td class="tg-yi9q">1.12</td>
  </tr>
  <tr>
    <td class="tg-0lax">4</td>
    <td class="tg-0lax">8.94</td>
    <td class="tg-yi9q">4.61</td>
  </tr>
  <tr>
    <td class="tg-0lax">5</td>
    <td class="tg-yi9q">2.24</td>
    <td class="tg-0lax">6.5</td>
  </tr>
  <tr>
    <td class="tg-0lax">6</td>
    <td class="tg-yi9q">3.61</td>
    <td class="tg-0lax">4.61</td>
  </tr>
</table>
</center>
<br>

The minimum distance between the points and the two clusters is colored in green.

We check that each point is in the correct group (i.e., the closest cluster). According to the distance in the table above, point 6 seems to be closer to the cluster 1 than to the cluster 2. Therefore, the allocation is not optimal and point 6 should be reallocated to cluster 1.

Step 5. We compute again the centers of the clusters after this reallocation. The centers are found by taking the mean of the coordinates *x* and *y* of the points belonging to the cluster. We thus have:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">points</th>
    <th class="tg-cly1">center</th>
  </tr>
  <tr>
    <td class="tg-cly1">cluster 1</td>
    <td class="tg-cly1">1, 5 &amp; 6</td>
    <td class="tg-cly1">(7.33, 6)</td>
  </tr>
  <tr>
    <td class="tg-0lax">cluster 2</td>
    <td class="tg-0lax">2, 3 &amp; 4</td>
    <td class="tg-0lax">(2, 3.33)</td>
  </tr>
</table>
</center>
<br>

where, for instance, 3.33 is simply $\frac{5+4+1}{3}$.

Step 6. Repeat step 4 until the allocation is optimal. If the allocation is optimal, the algorithm stops. In our example:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-scde{color:#009901;text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1">points</th>
    <th class="tg-cly1">Distance to cluster 1</th>
    <th class="tg-cly1">Distance to cluster 2</th>
  </tr>
  <tr>
    <td class="tg-cly1">1</td>
    <td class="tg-scde">3.02</td>
    <td class="tg-cly1">5.01</td>
  </tr>
  <tr>
    <td class="tg-cly1">2</td>
    <td class="tg-cly1">3.48</td>
    <td class="tg-scde">2.61</td>
  </tr>
  <tr>
    <td class="tg-cly1">3</td>
    <td class="tg-cly1">5.69</td>
    <td class="tg-scde">0.67</td>
  </tr>
  <tr>
    <td class="tg-cly1">4</td>
    <td class="tg-cly1">8.87</td>
    <td class="tg-scde">3.07</td>
  </tr>
  <tr>
    <td class="tg-cly1">5</td>
    <td class="tg-scde">1.95</td>
    <td class="tg-cly1">7.9</td>
  </tr>
  <tr>
    <td class="tg-cly1">6</td>
    <td class="tg-scde">2.4</td>
    <td class="tg-cly1">5.08</td>
  </tr>
</table>
</center>
<br>

All points are correctly allocated to its nearest cluster, so the allocation is optimal and the algorithm stops.

Step 7. State the final partition and the centers. In our example:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">points</th>
    <th class="tg-cly1">center</th>
  </tr>
  <tr>
    <td class="tg-cly1">cluster 1</td>
    <td class="tg-cly1">1, 5 &amp; 6</td>
    <td class="tg-cly1">(7.33, 6)</td>
  </tr>
  <tr>
    <td class="tg-cly1">cluster 2</td>
    <td class="tg-cly1">2, 3 &amp; 4</td>
    <td class="tg-cly1">(2, 3.33)</td>
  </tr>
</table>
</center>
<br>

We are now going to compute the quality of the partition we just found. Remember that we need to compute the BSS and TSS to find the quality. Below the steps to compute the quality of this partition by *k*-means, based on this summary table:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
.tg .tg-0lax{text-align:left;vertical-align:top}
.tg .tg-0a7q{border-color:#000000;text-align:left;vertical-align:middle}
.tg .tg-73oq{border-color:#000000;text-align:left;vertical-align:top}
</style>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0pky" colspan="3">cluster 1</th>
    <th class="tg-0pky" colspan="3">cluster 2</th>
  </tr>
  <tr>
    <td class="tg-0pky">point</td>
    <td class="tg-0pky">x</td>
    <td class="tg-0pky">y</td>
    <td class="tg-0pky">point</td>
    <td class="tg-0pky">x</td>
    <td class="tg-0pky">y</td>
  </tr>
  <tr>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">7</td>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">4</td>
    <td class="tg-0pky">5</td>
  </tr>
  <tr>
    <td class="tg-0pky">5</td>
    <td class="tg-0pky">9</td>
    <td class="tg-0pky">7</td>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">4</td>
  </tr>
  <tr>
    <td class="tg-0pky">6</td>
    <td class="tg-0pky">6</td>
    <td class="tg-0pky">8</td>
    <td class="tg-0pky">4</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">1</td>
  </tr>
  <tr>
    <td class="tg-0pky">mean</td>
    <td class="tg-0pky">7.33</td>
    <td class="tg-0pky">6</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">3.33</td>
  </tr>
</table>
</center>
<br>

Step 1. Compute the overall mean of the *x* and *y* coordinates:

$$\overline{\overline{x}} = \frac{7+4+2+0+9+6+3+5+4+1+7+8}{12} = 4.67$$

Step 2. Compute TSS and WSS:

$$TSS = (7-4.67)^2 + (4-4.67)^2 + (2-4.67)^2 + (0-4.67)^2 \\+ (9-4.67)^2 + (6-4.67)^2 + (3-4.67)^2 + (5-4.67)^2 \\ + (4-4.67)^2 + (1-4.67)^2 + (7-4.67)^2 + (8-4.67)^2 = 88.67$$

Regarding WSS, it is splitted for cluster 1 and for cluster 2. For cluster 1:

$$WSS[1] = (7-7.33)^2 + (9 - 7.33)^2 + (6 - 7.33)^2 \\ + (3-6)^2 + (7-6)^2 + (8-6)^2 = 18.67$$

For cluster 2:

$$WSS[2] = (4-2)^2 + (2-2)^2 + (0-2)^2 \\ + (5-3.33)^2 + (4-3.33)^2 + (1-3.33)^2 = 16.67$$

And $$WSS = WSS[1] + WSS[2] = 18.67 + 16.67 = 35.34$$

To find the BSS:

$$BSS = TSS - WSS = 88.67-35.34 = 53.33$$

Finally, the quality of the partition is:

$$Quality = \frac{BSS}{TSS} = \frac{53.33}{88.67} = 0.6014$$

So the quality of the partition is 60.14%.

We are now going to verify all these solutions (the partition, the final centers and the quality) in R.

#### Solution in R

As you can imagine, the solution in R us much shorter and requires much less computation on the user side. We first need to enter the data as a matrix or dataframe:

```{r}
X <- matrix(c(7,3,4,5,2,4,0,1,9,7,6,8),
            nrow = 6, byrow = TRUE)
X # display the coordinates of the points
```

We now perform the *k*-means via the `kmeans()` function with the point 5 and 6 as initial centers:

```{r}
# take rows 5 and 6 of the X matrix as initial centres
res.k <- kmeans(X, centers = X[c(5,6), ], algorithm = "Lloyd")
```

Unlike in the previous application with the dataset `Eurojobs.csv` where the initial centers are randomly chosen by R, in this second application we want to specify which points are going to be the two initial centers. For this, we need to set `centers = X[c(5,6), ]` to indicate that that there are 2 centers, and that they are going to be the points 5 and 6.

The reason for adding the argument `algorithm = "Lloyd"` can be found in the usage of the R function `kmeans()`. In fact, there are several variants of the *k*-means algorithm. The default choice is the @jaaw28m version, which is more sophisticated than the basic version detailed in the solution by hand. By using the original version of @lloyd1982least, we find the same solution in R and by hand. For more information, you can consult the documentation of the `kmeans()` function (via `?kmeans`) and read the articles mentioned.

The solution is then found by extracting

* the partition:

```{r}
res.k$cluster
```

Points 1, 5 and 6 belong to cluster 1, points 2, 3 and 4 belong to cluster 2.

* the coordinates of the final centers:

```{r}
# We extract the coordinates of the 2 final centers, rounded to 2 decimals
round(res.k$centers, digits = 2)
```

* and then the quality of the partition:

```{r}
res.k$betweenss / res.k$totss
```

The 3 results are equal to what we found by hand (except the quality which is slightly different due to rounding).

# Hierarchical clustering

Remind that the difference with the partition by *k*-means is that for hierarchical clustering, the number of classes is **not** specified in advance. Hierarchical clustering will help to determine the optimal number of clusters.

In this article, the 3 main types of hierarchical clustering are discussed:

* Single linkage (minimum distance)
* Complete linkage (maximum distance)
* Average linkage (average distance)

In the following sections, we perform these 3 algorithms by hand and verify the results in R.

## Application 3: hierarchical clustering

### Data

Using the data from the graph and the table below, perform **by hand** the 3 algorithms (single, complete and average linkage). Then **check** your answers **in R** and draw the dendrograms.

```{r, echo = FALSE}
n <- 5
set.seed(seed = 2018 * 02 * 13)
X <- as.data.frame(round(matrix(data = rnorm(2*n), nrow = n, byrow = TRUE), 2))
plot(X, asp = 1); text(X, labels = 1:5, pos = 3, cex = 1.5)
X
```

### Solution by hand

Step 1. For all 3 algorithms, we first need to compute the distance matrix between the 5 points thanks to the Pythagorean theorem. Remind that the distance between the point *a* and the point *b* is found with:

$$\sqrt{(x_a - x_b)^2 + (y_a - y_b)^2}$$

We apply this theorem to each pair of points, to finally have the following distance matrix (rounded to three decimals):

```{r, echo = FALSE}
round(dist(X), 3)
```

#### Single linkage

Step 2. From the distance matrix computed in step 1, we see that the **smallest distance** = 0.328 between points 2 and 4. 0.328 corresponds to the first height (more on this later when drawing the dendrogram). Since points 2 and 4 are the closest to each other, these 2 points are put together to form a single group. The groups are thus: 1, 2 & 4, 3 and 5. The new distances between the points 2 & 4 and all other points are now:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0pky"></th>
    <th class="tg-0pky">1</th>
    <th class="tg-0pky">2 &amp; 4</th>
    <th class="tg-0pky">3</th>
    <th class="tg-0pky">5</th>
  </tr>
  <tr>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">2 &amp; 4</td>
    <td class="tg-0pky">2.390</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">2.520</td>
    <td class="tg-0pky">0.483</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">5</td>
    <td class="tg-0pky">0.942</td>
    <td class="tg-0pky">1.530</td>
    <td class="tg-0pky">1.801</td>
    <td class="tg-0pky">0</td>
  </tr>
</table>
</center>
<br>

To construct this new distance matrix, proceed point by point:

* the distance between points 1 and 3 has not changed, so the distance is unchanged compared to the inital distance matrix (found in step 1), which was 2.520
* same goes for the distance between points 1 and 5 and points 3 and 5, the distances are the same than in the initial distance matrix since the points have not changed
* the distance between points 1 and 2 & 4 has changed since points 2 & 4 are now together
* since we are applying the **single linkage** criterion, the new distance between points 1 and 2 & 4 corresponds to the **minimum distance** between the distance between points 1 and 2 and the distance between points 1 and 4
* initial distance between points 1 and 2 is 2.675 and initial distance between points 1 and 4 is 2.390
* therefore, the minimum distance between these two distances is 2.390
* 2.390 is thus the new distance between points 1 and 2 & 4
* we apply the same process for points 3 and 2 & 4: the initial distance between points 3 and 2 is 0.483 and the initial distance between points 3 and 4 is 0.603. The minimum distance between these 2 distances is 0.483 so the new distance between points 3 and 2 & 4 is 0.483
* follow the same process for all other points

Step 3. Based on the distance matrix in step 2, the smallest distance is 0.483 between points 3 and 2 & 4 (the second height for the dendrogram). Since points 3 and 2 & 4 are the closest to each other, they are combined to form a new group, the group 2 & 3 & 4. The groups are thus: 1, 2 & 3 & 4 and 5. We construct the new distance matrix based on the same process detailed in step 2:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">1</th>
    <th class="tg-cly1">2 &amp; 3 &amp; 4</th>
    <th class="tg-cly1">5</th>
  </tr>
  <tr>
    <td class="tg-cly1">1</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">2 &amp; 3 &amp; 4</td>
    <td class="tg-cly1">2.390</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">5</td>
    <td class="tg-cly1">0.942</td>
    <td class="tg-cly1">1.530</td>
    <td class="tg-cly1">0</td>
  </tr>
</table>
</center>
<br>

* points 1 and 5 have not change, so the distance between these two points are the same than in previous step
* from step 2 we see that the distance between points 1 and 2 & 4 is 2.390 and the distance between points 1 and 3 is 2.520
* since we apply the single linkage criterion, we take the minimum distance, which is 2.390
* the distance between points 1 and 2 & 3 & 4 is thus 2.390
* same process for points 5 and 2 & 3 & 4

Step 4. Based on the distance matrix in step 3, the smallest distance is 0.942 between points 1 and 5 (the third height in the dendrogram). Since points 1 and 5 are the closest to each other, they are combined to form a new group, the group 1 & 5. The groups are thus: 1 & 5 and 2 & 3 & 4. We construct the new distance matrix based on the same process detailed in steps 2 and 3:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">1 &amp; 5</th>
    <th class="tg-cly1">2 &amp; 3 &amp; 4</th>
  </tr>
  <tr>
    <td class="tg-cly1">1 &amp; 5</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">2 &amp; 3 &amp; 4</td>
    <td class="tg-cly1">1.530</td>
    <td class="tg-cly1">0</td>
  </tr>
</table>
</center>
<br>

* the only distance left to compute is the distance between points 1 & 5 and 2 & 3 & 4
* from the previous step we see that the distance between points 1 and 2 & 3 & 4 is 2.390 and the distance between points 5 and 2 & 3 & 4 is 1.530
* since we apply the single linkage criterion, we take the minimum distance, which is 1.530
* the distance between points 1 & 5 and 2 & 3 & 4 is thus 1.530

Step 5. The final combination of points is the combination of points 1 & 5 and 2 & 3 & 4, with a final height of 1.530. Heights are used to draw the dendrogram in the final step.

Step 6. Draw the dendrogram thanks to the combination of points and the heights found above. Remember that:

* the first combination of points was between points 2 and 4, with a height of 0.328
* the second combination was between points 3 and 2 & 4 with a height of 0.483
* the third combination was between points 1 and 5 with a height of 0.942
* the final combination was between points 1 & 5 and 2 & 3 & 4 with a height of 1.530
* this is exactly what is illustrated in the following dendrogram:

```{r, echo = FALSE}
hclust <- hclust(dist(X), method = "single")
plot(hclust)
```

#### Complete linkage

Complete linkage is quite similar to single linkage, except that instead of taking the smallest distance when computing the new distance between points that have been grouped, the **maximum distance** is taken.

The steps to perform the hierarchical clustering with the complete linkage (maximum) are detailed below.

Step 1. Step 1 is exactly the same than for single linkage, that is, we compute the distance matrix of the 5 points thanks to the Pythagorean theorem. This gives us the following distance matrix:

```{r, echo = FALSE}
round(dist(X), 3)
```

Step 2. From the distance matrix computed in step 1, we see that the **smallest distance** = 0.328 between points 2 and 4. It is important to note that even if we apply the complete linkage, in the distance matrix the points are brought together based on the smallest distance. This is the case for all 3 algorithms. The difference between the 3 algorithms lies in how to compute the new distances between the new combination of points (the single linkage takes the minimum between the distances, the complete linkage takes the maximum distance and the average linkage takes the average distance). 0.328 corresponds to the first height (which will be used when drawing the dendrogram). Since points 2 and 4 are the closest to each other, these 2 points are put together to form a single group. The groups are thus: 1, 2 & 4, 3 and 5. The new distances between the points 2 & 4 and all other points are now:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0pky"></th>
    <th class="tg-0pky">1</th>
    <th class="tg-0pky">2 &amp; 4</th>
    <th class="tg-0pky">3</th>
    <th class="tg-0pky">5</th>
  </tr>
  <tr>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">2 &amp; 4</td>
    <td class="tg-0pky">2.675</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">2.520</td>
    <td class="tg-0pky">0.603</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">5</td>
    <td class="tg-0pky">0.942</td>
    <td class="tg-0pky">1.841</td>
    <td class="tg-0pky">1.801</td>
    <td class="tg-0pky">0</td>
  </tr>
</table>
</center>
<br>

To construct this new distance matrix, proceed point by point:

* the distance between points 1 and 3 has not changed, so the distance is unchanged compared to the inital distance matrix (found in step 1), which was 2.520
* same goes for the distance between points 1 and 5 and points 3 and 5, the distances are the same than in the initial distance matrix since the points have not changed
* the distance between points 1 and 2 & 4 has changed since points 2 & 4 are now together
* since we are applying the **complete linkage** criterion, the new distance between points 1 and 2 & 4 corresponds to the **maximum distance** between the distance between points 1 and 2 and the distance between points 1 and 4
* initial distance between points 1 and 2 is 2.675 and initial distance between points 1 and 4 is 2.390
* therefore, the maximum distance between these two distances is 2.675
* 2.675 is thus the new distance between points 1 and 2 & 4
* we apply the same process for points 3 and 2 & 4: the initial distance between points 3 and 2 is 0.483 and the initial distance between points 3 and 4 is 0.603. The maximum distance between these 2 distances is 0.603 so the new distance between points 3 and 2 & 4 is 0.603
* follow the same process for all other points

Step 3. Based on the distance matrix in step 2, the smallest distance is 0.603 between points 3 and 2 & 4 (the second height for the dendrogram). Since points 3 and 2 & 4 are the closest to each other, they are combined to form a new group, the group 2 & 3 & 4. The groups are thus: 1, 2 & 3 & 4 and 5. We construct the new distance matrix based on the same process detailed in step 2:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">1</th>
    <th class="tg-cly1">2 &amp; 3 &amp; 4</th>
    <th class="tg-cly1">5</th>
  </tr>
  <tr>
    <td class="tg-cly1">1</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">2 &amp; 3 &amp; 4</td>
    <td class="tg-cly1">2.675</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">5</td>
    <td class="tg-cly1">0.942</td>
    <td class="tg-cly1">1.841</td>
    <td class="tg-cly1">0</td>
  </tr>
</table>
</center>
<br>

* points 1 and 5 have not change, so the distance between these two points are the same than in previous step
* from step 2 we see that the distance between points 1 and 2 & 4 is 2.675 and the distance between points 1 and 3 is 2.520
* since we apply the complete linkage criterion, we take the maximum distance, which is 2.675
* the distance between points 1 and 2 & 3 & 4 is thus 2.675
* same process for points 5 and 2 & 3 & 4

Step 4. Based on the distance matrix in step 3, the smallest distance is 0.942 between points 1 and 5 (the third height in the dendrogram). Since points 1 and 5 are the closest to each other, they are combined to form a new group, the group 1 & 5. The groups are thus: 1 & 5 and 2 & 3 & 4. We construct the new distance matrix based on the same process detailed in steps 2 and 3:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">1 &amp; 5</th>
    <th class="tg-cly1">2 &amp; 3 &amp; 4</th>
  </tr>
  <tr>
    <td class="tg-cly1">1 &amp; 5</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">2 &amp; 3 &amp; 4</td>
    <td class="tg-cly1">2.675</td>
    <td class="tg-cly1">0</td>
  </tr>
</table>
</center>
<br>

* the only distance left to compute is the distance between points 1 & 5 and 2 & 3 & 4
* from the previous step we see that the distance between points 1 and 2 & 3 & 4 is 2.675 and the distance between points 5 and 2 & 3 & 4 is 1.841
* since we apply the complete linkage criterion, we take the maximum distance, which is 2.675
* the distance between points 1 & 5 and 2 & 3 & 4 is thus 2.675

Step 5. The final combination of points is the combination of points 1 & 5 and 2 & 3 & 4, with a final height of 2.675. Heights are used to draw the dendrogram in the final step.

Step 6. Draw the dendrogram thanks to the combination of points and the heights found above. Remember that:

* the first combination of points was between points 2 and 4, with a height of 0.328
* the second combination was between points 3 and 2 & 4 with a height of 0.603
* the third combination was between points 1 and 5 with a height of 0.942
* the final combination was between points 1 & 5 and 2 & 3 & 4 with a height of 2.675
* this is exactly what is illustrated in the following dendrogram:

```{r, echo = FALSE}
hclust <- hclust(dist(X), method = "complete")
plot(hclust)
```

#### Average linkage

With the average linkage criterion, it is not the minimum nor the maximum distance that is taken when computing the new distance between points that have been grouped, but it is, as you guessed by now, the **average distance** between the points.

The steps to perform the hierarchical clustering with the average linkage are detailed below.

Step 1. Step 1 is exactly the same than for single and complete linkage, that is, we compute the distance matrix of the 5 points thanks to the Pythagorean theorem. This gives us the following distance matrix:

```{r, echo = FALSE}
round(dist(X), 3)
```

Step 2. From the distance matrix computed in step 1, we see that the **smallest distance** = 0.328 between points 2 and 4. It is important to note that even if we apply the average linkage, in the distance matrix the points are brought together based on the smallest distance. This is the case for all 3 algorithms. The difference between the 3 algorithms lies in how to compute the new distances between the new combination of points (the single linkage takes the minimum between the distances, the complete linkage takes the maximum distance and the average linkage takes the average distance). 0.328 corresponds to the first height (which will be used when drawing the dendrogram). Since points 2 and 4 are the closest to each other, these 2 points are put together to form a single group. The groups are thus: 1, 2 & 4, 3 and 5. The new distances between the points 2 & 4 and all other points are now:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-0pky"></th>
    <th class="tg-0pky">1</th>
    <th class="tg-0pky">2 &amp; 4</th>
    <th class="tg-0pky">3</th>
    <th class="tg-0pky">5</th>
  </tr>
  <tr>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">2 &amp; 4</td>
    <td class="tg-0pky">2.5325</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">2.520</td>
    <td class="tg-0pky">0.543</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">5</td>
    <td class="tg-0pky">0.942</td>
    <td class="tg-0pky">1.6855</td>
    <td class="tg-0pky">1.801</td>
    <td class="tg-0pky">0</td>
  </tr>
</table>
</center>
<br>

To construct this new distance matrix, proceed point by point:

* the distance between points 1 and 3 has not changed, so the distance is unchanged compared to the inital distance matrix (found in step 1), which was 2.520
* same goes for the distance between points 1 and 5 and points 3 and 5, the distances are the same than in the initial distance matrix since the points have not changed
* the distance between points 1 and 2 & 4 has changed since points 2 & 4 are now together
* since we are applying the **average linkage** criterion, the new distance between points 1 and 2 & 4 corresponds to the **average distance** between the distance between points 1 and 2 and the distance between points 1 and 4
* initial distance between points 1 and 2 is 2.675 and initial distance between points 1 and 4 is 2.390
* therefore, the average distance between these two distances is $\frac{2.675 + 2.390}{2} = 2.5325$
* 2.5325 is thus the new distance between points 1 and 2 & 4
* we apply the same process for points 3 and 2 & 4: the initial distance between points 3 and 2 is 0.483 and the initial distance between points 3 and 4 is 0.603. The average distance between these 2 distances is 0.543 so the new distance between points 3 and 2 & 4 is 0.543
* follow the same process for all other points

Step 3. Based on the distance matrix in step 2, the smallest distance is 0.543 between points 3 and 2 & 4 (the second height for the dendrogram). Since points 3 and 2 & 4 are the closest to each other, they are combined to form a new group, the group 2 & 3 & 4. The groups are thus: 1, 2 & 3 & 4 and 5. We construct the new distance matrix based on the same process detailed in step 2:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">1</th>
    <th class="tg-cly1">2 &amp; 3 &amp; 4</th>
    <th class="tg-cly1">5</th>
  </tr>
  <tr>
    <td class="tg-cly1">1</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">2 &amp; 3 &amp; 4</td>
    <td class="tg-cly1">2.528333</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">5</td>
    <td class="tg-cly1">0.942</td>
    <td class="tg-cly1">1.724</td>
    <td class="tg-cly1">0</td>
  </tr>
</table>
</center>
<br>

* points 1 and 5 have not change, so the distance between these two points are the same than in previous step
* from step 2 we see that the distance between points 1 and 2 & 4 is 2.5325 and the distance between points 1 and 3 is 2.520
* since we apply the average linkage criterion, we take the average distance
* however, we have to take into the consideration that there are 2 points in the group 2 & 4, while only one point in the group 3
* the average distance for the distance between 1 and 2 & 3 & 4 is thus: $\frac{(2 \cdot 2.5325) + (1 \cdot 2.520)}{3} = 2.528333$
* same process for points 5 and 2 & 3 & 4: $\frac{(2 \cdot 1.6855) + (1 \cdot 1.801)}{3} = 1.724$

Step 4. Based on the distance matrix in step 3, the smallest distance is 0.942 between points 1 and 5 (the third height in the dendrogram). Since points 1 and 5 are the closest to each other, they are combined to form a new group, the group 1 & 5. The groups are thus: 1 & 5 and 2 & 3 & 4. We construct the new distance matrix based on the same process detailed in steps 2 and 3:

<center>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-cly1{text-align:left;vertical-align:middle}
</style>
<table class="tg">
  <tr>
    <th class="tg-cly1"></th>
    <th class="tg-cly1">1 &amp; 5</th>
    <th class="tg-cly1">2 &amp; 3 &amp; 4</th>
  </tr>
  <tr>
    <td class="tg-cly1">1 &amp; 5</td>
    <td class="tg-cly1">0</td>
    <td class="tg-cly1"></td>
  </tr>
  <tr>
    <td class="tg-cly1">2 &amp; 3 &amp; 4</td>
    <td class="tg-cly1">2.126167</td>
    <td class="tg-cly1">0</td>
  </tr>
</table>
</center>
<br>

* the only distance left to compute is the distance between points 1 & 5 and 2 & 3 & 4
* from the previous step we see that the distance between points 1 and 2 & 3 & 4 is 2.528333 and the distance between points 5 and 2 & 3 & 4 is 1.724
* since we apply the average linkage criterion, we take the average distance, which is $\frac{2.528333 + 1.724}{2} = 2.126167$
* the distance between points 1 & 5 and 2 & 3 & 4 is thus 2.126167

Step 5. The final combination of points is the combination of points 1 & 5 and 2 & 3 & 4, with a final height of 2.126167. Heights are used to draw the dendrogram in the final step.

Step 6. Draw the dendrogram thanks to the combination of points and the heights found above. Remember that:

* the first combination of points was between points 2 and 4, with a height of 0.328
* the second combination was between points 3 and 2 & 4 with a height of 0.543
* the third combination was between points 1 and 5 with a height of 0.942
* the final combination was between points 1 & 5 and 2 & 3 & 4 with a height of 2.126167
* this is exactly what is illustrated in the following dendrogram:

```{r, echo = FALSE}
hclust <- hclust(dist(X), method = "average")
plot(hclust)
```

### Solution in R

To perform the hierarchical clustering with any of the 3 criterion in R, we first need to enter the data (in this case as a matrix format, but it can also be performed on dataframes):

```{r}
X <- matrix(c(2.03,0.06,-0.64,-0.10,-0.42,-0.53,-0.36,0.07,1.14,0.37),
            nrow = 5, byrow = TRUE)
```

#### Single linkage

We can apply the hierarchical clustering with the single linkage criterion thanks to the `hclust()` function with the argument `method = "single"`:

```{r}
# Hierarchical clustering: single linkage 
hclust <- hclust(dist(X), method = "single")
```

Note that the `hclust()` function requires a distance matrix. If your data is not already a distance matrix (like in our case, as the matrix `X` corresponds to the coordinates of the 5 points), you can transform it into a distance matrix with the `dist()` function.

We can now plot the dendrogram to check our results by hand found above:

```{r}
plot(hclust)
```

As we can see from the dendrogram, the combination of points and the heights are the same than the ones obtained by hand. 

Remember that hierarchical clustering is used to determine the optimal number of clusters. This optimal number of clusters can be determined thanks to the dendrogram. For this, we usually look at the largest difference of heights:

![How to determine the number of clusters from a dendrogram? Take the largest difference of heights and count how many vertical lines you see](/blog/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r_files/dendrogram-single-linkage.png)

The largest difference of heights in the dendrogram occurs before the final combination, that is, before the combination of the group 2 & 3 & 4 with the group 1 & 5. To determine the optimal number of clusters, simply count how many vertical lines you see within this largest difference. In our case, the optimal number of clusters is thus 2. In R, we can even highlight these two clusters directly in the dendrogram with the `rect.hclust()` function:

```{r}
plot(hclust)
rect.hclust(hclust, k = 2, # k is used to specify the number of clusters
            border = "blue")
```

Finally, we could also determine the optimal number of cluster thanks to a barplot the heights (stored in `$height` of the clustering output):

```{r}
barplot(hclust$height,
        names.arg = (nrow(X) - 1) : 1) # show the number of cluster below each bars
```

Again, look for the largest jump of heights. In our case, the largest jump is from 1 to 2 classes. Therefore, the optimal number of classes is 2.

Note that determining the number of clusters using the dendrogram or barplot is not a strict rule. You can also consider the _Silhouette plot_, _elbow plot_ or some numerical measures such as Dunn's index, Hubert's gamma, etc., which show the variation of the error with the number of clusters (*k*), and you choose the value of *k* where the error is smallest. However, these methods are outside the scope of this course and the method presented with the dendrogram is sufficient.

#### Complete linkage

We can apply the hierarchical clustering with the complete linkage criterion thanks to the `hclust()` function with the argument `method = "complete"`:

```{r}
# Hierarchical clustering: complete linkage 
hclust <- hclust(dist(X), method = "complete")
```

Note that the `hclust()` function requires a distance matrix. If your data is not already a distance matrix (like in our case, as the matrix `X` corresponds to the coordinates of the 5 points), you can transform it into a distance matrix with the `dist()` function.

We can now plot the dendrogram to check our results by hand found above:

```{r}
plot(hclust)
```

As we can see from the dendrogram, the combination of points and the heights are the same than the ones obtained by hand.

Like for the single linkage, the largest difference of heights in the dendrogram occurs before the final combination, that is, before the combination of the group 2 & 3 & 4 with the group 1 & 5. In this case, the optimal number of clusters is thus 2. In R, we can even highlight these two clusters directly in the dendrogram with the `rect.hclust()` function:

```{r}
plot(hclust)
rect.hclust(hclust, k = 2, # k is used to specify the number of clusters
            border = "blue")
```

#### Average linkage

We can apply the hierarchical clustering with the average linkage criterion thanks to the `hclust()` function with the argument `method = "average"`:

```{r}
# Hierarchical clustering: average linkage 
hclust <- hclust(dist(X), method = "average")
```

Note that the `hclust()` function requires a distance matrix. If your data is not already a distance matrix (like in our case, as the matrix `X` corresponds to the coordinates of the 5 points), you can transform it into a distance matrix with the `dist()` function.

We can now plot the dendrogram to check our results by hand found above:

```{r}
plot(hclust)
```

As we can see from the dendrogram, the combination of points and the heights are the same than the ones obtained by hand.

Like for the single and complete linkages, the largest difference of heights in the dendrogram occurs before the final combination, that is, before the combination of the group 2 & 3 & 4 with the group 1 & 5. In this case, the optimal number of clusters is thus 2. In R, we can even highlight these two clusters directly in the dendrogram with the `rect.hclust()` function:

```{r}
plot(hclust)
rect.hclust(hclust, k = 2, # k is used to specify the number of clusters
            border = "blue")
```

# *k*-means versus hierarchical clustering

Choosing between *k*-means and hierarchical clustering is not always easy. If you have a good reason to think that there is a specific number of clusters in your dataset (for example if you have one group of healthy patients, and another group of diseased patients but you do not know which group the patients belong to), you should probably opt for the *k*-means clustering as this technique is used when the number of groups is specified in advance. If you do not have any reason to believe there is a certain number of groups in your dataset xxx to continue

Thanks for reading. I hope this article helped you understand the different clustering methods and how to compute them by hand and in R.

As always, if you have a question or a suggestion related to the topic covered in this article, please add it as a comment so other readers can benefit from the discussion. If you find a mistake or bug, you can inform me by <a href="https://github.com/AntoineSoetewey/statsandr/issues" target="_blank" rel="noopener">raising an issue on GitHub</a>. For all other requests, you can contact me [here](/contact/).

Get updates every time a new article is published by [subscribing to this blog](/subscribe/).

**Related articles:**

<script src="//rss.bloople.net/?url=https%3A%2F%2Fwww.statsandr.com%2Ftags%2Fr%2Findex.xml&detail=-1&limit=5&showtitle=false&type=js"></script>

# References